#### 4.redis新的3种数据类型

##### 4.1 Bitmaps：位操作字符串

###### 4.1.1 简介

>现代计算机使用二进制（位）作为信息的基本单位，1个字节等于8位，例如“abc”字符串是有3个字节组成，但实际在计算机内存储时将其使用二进制表示，“abc”分别对应的ASCII码是：97、98、99，对应的二进制分别是01100001、01100010、01100011
>
>合理地使用位操作能够有效地提高内存使用率和开发效率
>
>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作
>
>* Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作，字符串中每个字符对应1个字节，也就是8位，一个字符可以存储8个bit位信息
>* Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量

###### 4.1.2常用命令

**setbit:设置某个偏移值（0或1）**

```
setbit key offset value
```

> 设置offset偏移位的值为value，offset的值是从0开始的，n代表第n+1个bit位置的
>
> offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)
>
> value 的值只能为0或1
>
> 返回值 指定偏移量原来储存的位

**getbit:获取某个偏移位的值**

```
getbit key offset
```

> 获取key所对应的bitmaps中offset偏移位的值

**bitcount:统计bit位都是为1的数量**

```
bitcount key [start] [end]
```

> 统计字符串被设置为1的bit数，一般情况下，给定的整个字符串都会被进行统计，通过指定额外的start或者end参数，可以让计数只在特定的位上进行， start 和 end 参数，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推

**bittop:对一个多个bitmaps执行位操作**

```
bittop operation destkey key [key ...]
```

> 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上
>
> operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：
>
> * BITOP AND destkey key [key ...] ，对一个或多个 key 求逻辑并，并将结果保存到destkey
>
> * BITOP OR destkey key [key ...] ，对一个或多个 key 求逻辑或，并将结果保存到
>
>   destkey
>
> * BITOP XOR destkey key [key ...] ，对一个或多个 key 求逻辑异或，并将结果保存到destkey
>
> * BITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey
>
> 除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入
>
> 返回值： 保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等

##### 4.1.3 bitmaps与set比较

>假设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和 Bitmaps 分别存储活跃用户可以得到表
>
>**set** **和** **Bitmaps** 存储一天活跃用户对比
>
>| 数据类型 | 每个用户id占用空间 | 需要存储的用户量 | 全部内存量                |
>| -------- | ------------------ | ---------------- | ------------------------- |
>| set集合  | 64位               | 50000000         | 64 位 * 50000000 = 400MB  |
>| Bitmaps  | 1位                | 100000000        | 1 位 * 100000000 = 12.5MB |
>
>很明显， 这种情况下使用 Bitmaps 能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观
>
>**set** **和** **Bitmaps** 存储独立用户空间对比
>
>| 数据类型 | 一天   | 一月  | 一年  |
>| -------- | ------ | ----- | ----- |
>| set集合  | 400MB  | 12GB  | 144GB |
>| Bitmaps  | 12.5MB | 375MB | 4.5GB |
>
>但 Bitmaps 并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有 10 万（大量的僵尸用户）， 那么两者的对比如下表所示， 很显然， 这时候使用 Bitmaps 就不太合适了， 因为基本上大部分位都是 0
>
>| 数据类型 | 每个userid占用空间 | 需要存储的用户量 | 全部内存量                |
>| -------- | ------------------ | ---------------- | ------------------------- |
>| set集合  | 64 位              | 100000           | 64 位 * 100000 = 800KB    |
>| Bitmaps  | 1 位               | 100000000        | 1 位 * 100000000 = 12.5MB |



#### 4.2 HyperLoglog

##### 4.2.1 简介

>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV（PageView 页面访问量），可以使用 Redis 的 incr、incrby 轻松实现。但像UV（UniqueVisitor 独立访客）、独立 IP 数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题
>
>解决基数问题有很多种方案：
>
>数据存储在 MySQL 表中，使用 distinct count 计算不重复个数
>
>使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理
>
>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否能够降低一定的精度来平衡存储空间？Redis 推出了 HyperLogLog.
>
>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的
>
>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比
>
>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以HyperLogLog 不能像集合那样，返回输入的各个元素。
>
>什么是基数？
>
>比如数据集 {1, 3, 5, 7, 5, 7, 8}，那么这个数据集的基数集为 {1, 3, 5 ,7, 8}，基数 (不重复元素) 为 5。 基数估计就是在误差可接受的范围内，快速计算基数

##### 4.2.2 命令

**pfadd:添加多个元素**

```
pfadd key element [element ...]
```

> 向HyperLoglog类型的key中添加一个或者多个元素
>
> 添加一个或者多个元素到key对应的集合中
>
> 返回值：
>
> 1：添加成功
>
> 0：添加失败

**pfcount:获取每个HLL合并后元素的个数**

```
pfcount key1 key2 ...
```

> 统计一个或者多个key去重后元素的数量

**pfmerge:将多个HLL合并后元素放入另外一个HLL**

```
pfmerge destkey sourcekey [sourcekey ...]
```

> 将多个 sourcekey 合并后放到 destkey 中

#### 4.3 Geographic

##### 4.3.1 简介

> Reids3.2 中增加了对GEO类型的支持，GEO（Geographic），地理信息的缩写。
>
> 该类型，就是元素的 2 维坐标，在地图上就是经纬度，redis基于该类型，提供了经纬度设置、查询、范围查询、距离查询，经纬度Hash等常见操作

##### 4.3.2 命令

**geoadd:添加多个位置的经纬度**

```
geoadd key longitude latitude member [longitude latitude member ...]
```

> longitude latitude member：经度 纬度 名称
>
> 两级无法直接添加，一般会下载城市数据，直接通过java程序一次性导入
>
> 有效的经纬度从-180度到180度，有效的维度从-85.05112878度到85.05112878度
>
> 当坐标位置超出指定范围时，该命令将会返回一个错误
>
> 已经添加的数据，是无法再次往里面添加的

**geopos：获取多个位置的坐标值**

```
geopos key member [member ...]
```

**geodist:获取两个位置的直线距离**

```
geodist key member1 member2 [m|km|ft|mi]
```

> 单位：[m|km|ft|mi] -》[米|千米|英里|英尺]，默认为米

**georadius:以给定的经纬度为中心，找出某一半径内元素**

```
georadius key longitude latitude radius m|km|ft|mi
```

> 单位：[m|km|ft|mi] -》[米|千米|英里|英尺]，默认为米



