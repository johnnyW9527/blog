#### 1. 时间语义

![](C:\study\mlog\picture\52.png)

* eventTime : 表示日志事件产生的时间戳，每一条数据都会记录自己生产的时间
* ingestionTime:表示 数据进入 Flink程序的时间
* processingTime:表示数据被计算处理时间，默认Flink时间属性就是ProcessingTime

```java
StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        /**
         * 参数 TimeCharacteristic 有三种类型：
         * ProcessingTime,
         * IngestionTime,
         * EventTime;
         */
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
```

#### 2 watermark

##### 2.1 作用

Watermark 是一种衡量 Event Time 进展的机制。
Watermark 是用于处理乱序事件的，而正确的处理乱序事件，通常用Watermark 机制结合 window 来实现

##### 2.2  watermark assigner

###### 2.2.1 AssignerWithPeriodicWatermarks 周期性更新

周期性的生成 watermark：系统会周期性的将 watermark 插入到流中(水位线也是一种特殊的事件!)。默认周期是 200 毫秒。可以使用
ExecutionConfig.setAutoWatermarkInterval()方法进行设置

```java
StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        // 设置 EventTime 特征
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        // 设置 Watermark 周期性更新
        env.getConfig().setAutoWatermarkInterval(500L);
```

产生watermark 的逻辑：每隔 5 秒钟，Flink 会调用
AssignerWithPeriodicWatermarks 的 getCurrentWatermark()方法。
如果方法返回一个时间戳大于之前水位的时间戳，新的 watermark 会被插入到流中。这个检查保证了水位线是单调递增的。如果方法返回的时间戳小于等于之前水位的时间戳，则不会产生新的watermark。

```java
import com.tan.flink.bean.SensorReading;
import com.tan.flink.source.SourceFromCustom;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.AssignerWithPeriodicWatermarks;
import org.apache.flink.streaming.api.watermark.Watermark;
import org.apache.flink.streaming.api.windowing.time.Time;
import javax.annotation.Nullable;

public class Watermark_CustomPeriodicWatermark {
   
     
    public static void main(String[] args) throws Exception {
   
     
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        env.getConfig().setAutoWatermarkInterval(500L);
        DataStreamSource<SensorReading> inputDataStream = env.addSource(new SourceFromCustom.CustomSource());
        SingleOutputStreamOperator<SensorReading> resultDataStream = inputDataStream.keyBy("id")
                .assignTimestampsAndWatermarks(new CustomPeriodicWatermark())
                .timeWindowAll(Time.seconds(5L))
                .maxBy("temperature");
        resultDataStream.print();
        env.execute();
    }

    /**
     * SensorReading -> 输入类型
     */
    public static class CustomPeriodicWatermark implements AssignerWithPeriodicWatermarks<SensorReading> {
   
     

        // 延迟时间
        private long bound = 2 * 1000;
        // 最大事件时间戳
        private long maxEventTime = Long.MIN_VALUE;

        // 返回 获取当前 watermark
        @Nullable
        @Override
        public Watermark getCurrentWatermark() {
   
     
            return new Watermark(maxEventTime - bound);
        }

        // 提取日志数据事件时间戳
        @Override
        public long extractTimestamp(SensorReading sensorReading, long lastEventTime) {
   
     
            // 判断当前数据的事件时间戳是否大于当前窗口（数据集）的最大事件时间戳
            // 如果是 则更新 maxEventTime 否则不做任何处理
            maxEventTime = Math.max(sensorReading.getTimestamp(), maxEventTime);
            // 返回当前数据的时间戳
            return sensorReading.getTimestamp();
        }
    }
}
```

###### 2.2.2 Assigner with punctuated watermarks 间断性更新

间断式地生成 watermark。和周期性生成的方式不同，这种方式不是固定时间的，而是可以根据需要对每条数据进行筛选和处理

```java
import com.tan.flink.bean.SensorReading;
import com.tan.flink.source.SourceFromCustom;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.AssignerWithPunctuatedWatermarks;
import org.apache.flink.streaming.api.watermark.Watermark;
import javax.annotation.Nullable;

public class Watermark_CustomPunctuatedWatermark {
   
     
    public static void main(String[] args) throws Exception {
   
     
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        // 不再设置周期行性获取watermark
        // env.getConfig().setAutoWatermarkInterval(500L);
        DataStreamSource<SensorReading> inputDataStream = env.addSource(new SourceFromCustom.CustomSource());
        SingleOutputStreamOperator<SensorReading> resultDataStream = inputDataStream.assignTimestampsAndWatermarks(new CustomPunctuatedWatermark());
        resultDataStream.print();
        env.execute();

    }

    public static class CustomPunctuatedWatermark implements AssignerWithPunctuatedWatermarks<SensorReading> {
   
     

        // 延迟 2s
        private long bound = 2 * 1000L;

        /**
         * @param lastElement      -> 上一条数据
         * @param extractTimestamp -> 当前数据的时间戳 根据 extractTimestamp 方法获取
         * @return
         */
        @Nullable
        @Override
        public Watermark checkAndGetNextWatermark(SensorReading lastElement, long extractTimestamp) {
   
     
            // 如果上一条数据的id 等于 sensor_1 则更新时间戳 否则返回 null
            if ("sensor_1".equals(lastElement.getId())) {
   
     
                return new Watermark(extractTimestamp - bound);
            } else {
   
     
                return null;
            }
        }

        /**
         * @param sensorReading            -> 当前数据
         * @param previousElementTimestamp -> 上一条数据的事件事件戳
         * @return
         */
        @Override
        public long extractTimestamp(SensorReading sensorReading, long previousElementTimestamp) {
   
     
            return sensorReading.getTimestamp();
        }
    }
}
```

#### 3 总结

1. 有序情况

一种简单的特殊情况是，如果我们事先得知数据流的时间戳是单调递增的，也就是说没有乱序，那我们可以使用AscendingTimestampExtractor，这个类会直接使用数据的时间戳生成 watermark

```java
inputDataStream.assignTimestampsAndWatermarks(new AscendingTimestampExtractor<SensorReading>() {
   
     
            @Override
            public long extractAscendingTimestamp(SensorReading sensorReading) {
   
     
                return sensorReading.getTimestamp();
            }
        });
```

2. 无序情况

而对于乱序数据流，如果我们能大致估算出数据流中的事件的最大延迟时间

```java
inputDataStream.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor<SensorReading>(Time.seconds(2L)) {
   
     
            @Override
            public long extractTimestamp(SensorReading sensorReading) {
   
     
                return sensorReading.getTimestamp();
            }
        });
```