#### 6. 基于DSL的查询

##### 6.1 什么 是DSL

> DSL: Domain Specific Language, 领域特定语言, 指的是专注于某个应用程序领域的、具有高度针对性的计算机语言.
>
> **Query String 与 Query DSL之间的区别:**
>
> Query String: 在请求的URL后直接拼接查询条件;
> Query DSL: 在请求的Request Body中携带查询条件
>
> **DSL功能强大, 可以构建复杂的查询、过滤、聚合条件, 所以这种查询方式的用途最广.**

##### 6.2 _validate - 校验查询语句是否合法

> **对于复杂的查询, 很有必要在查询前使用`validate API`进行验证, 保证DSL语句的正确有效:**
>
> ```shell
> // 要查询name中包含"java"的文档: 
> GET shop/it_book/_validate/query?explain
> {
> 	"query": {
>         "math": {            // 错误的查询名称, 应该是match
>             "name": "java"
>         }
>     }
> }
> 
> // 校验结果: 
> {
>     "valid": false,
>     "error": "org.elasticsearch.common.ParsingException: no [query] registered for [math]"
> }
> 
> // 修改math为match后, 校验结果为: 
> {
>     "valid": true,
>     "_shards": {
>         "total": 1,
>         "successful": 1,
>         "failed": 0
>     },
>     "explanations": [
>         {
>             "index": "shop",
>             "valid": true,    // 校验通过, DSL有效
>             "explanation": "+name:java_type:it_book"  // 查询条件, +表示必须存在
>         }
>     ]
> }
> ```

##### 6.3 match query - 匹配查询

> 1. 查询所有文档
>
> ```
> GET shop/it_book/_search
> {
>     "query": {
>         "match_all": {}
>     }
> }
> ```
>
> 2. 查询满足一定条件的文档
>
> ```
> 查询name中包含"java"的文档, 同时按照价格升序排序
> GET shop/it_book/_search
> {
>     "query": {
>         "match": {
>             "name": "java"
>         }
>     }, 
>     "sort": [
>         { 
>             "price": {"order": "asc"} 
>         }
>     ]
> }
> ```
>
> 3. 分页查询文档
>
> ```
> GET shop/it_book/_search
> {
>     "query": {
>         "match_all": {}
>     },
>     "from": 0,      // 开始记录数, 起始数为0
>     "size": 1       // 页大小, 即每页显示的记录数
> }
> ```
>
> 4. 指定返回的结果种包含的字段
>
> ```
> GET shop/it_book/_search
> {
>     "query": {
>         "match_all": {}
>     }, 
>     "_source": [
>         "name", 	// 显示商品名称
>         "price"		// 显示商品价格
>     ]
> }
> ```

##### 6.4 精确查询 - match_phrase

> 不同的数据类型在建立倒排索引时, 有的会作为full text处理, 有的作为exact value处理.对查询串分词时, 使用的分析器(analyzer)必须和创建index时使用的相同, 否则将检索不到准确的数据.
>
> 1. 精确匹配 - exact value
>
> 常见的exact value类型有date - 日期类型.
>
> **ES检索时, 不会对String进行分词, 而是完全根据String的值去精确匹配, 查找相应的文档.**
>
> 在DSL中, 通过`match_phrase`短语匹配达到精确匹配的目的 —— 不会对查询串进行分词, 而是直接精确匹配查找
>
> ```
> 示例:查询name中包含"thinking in java"的文档, 不会对查询串进行分词:
> GET shop/_search
> {
>     "query": {
>         "match_phrase": {
>             "name": "thinking in java"
>         }
>     }
> }
> ```
>
> 2. 全文检索 - full text
>
> 常见的full text类型有: text - 文本串
>
> **ES检索时, 会对检索串进行分词, 包括缩写、时态、同义词等转换手段, 然后根据分词结果与倒排索引进行匹配, 查找相应的文档.**
>
> 索引中只要有任意一个相关field的分词 匹配拆分后的词, 这个文档就可以出现在结果中, 只是匹配度越高的排名越靠前.
>
> ```
> 示例:查询name中包含"thinking in java"的文档, 会将查询串拆分为"think", "in", "java"三个词:
> GET shop/_search
> {
>     "query": {
>         "match": {
>             "name": "thinking in java"
>         }
>     }
> }
> ```

##### 6.5 控制匹配规则 - operator

> `operator` 操作符, 用来指定ES对分词后的词项如何进行检索过滤. 选项有:
>
> and, 作用 == match_phrase, 即全部匹配;
> or, 作用 == match, 即部分匹配.
>
> ```
> GET shop/_search
> {
>     "query": {
>         "match": {
>             "name": {					// 要查询的field 
>                 "query": "编程思想",
>                 "operator": "or"		// 操作符
>             }
>         }
>     }
> }
> ```

##### 6.6 指定命中的百分比 - minimum_should_match

> `minimum_should_match` 用来指定最少要匹配多少比例的分词, 才算符合条件并返回结果.
>
> ```
> 示例:搜索name中包含"并发编程的艺术", 被拆分成"并发", "编程", "艺术"等词, 现在要求至少匹配50%的分词, 可以这样:
> GET shop/_search
> {
>     "query": {
>         "match": {
>             "name": {
>                 "query": "并发编程的艺术", 
>                 "minimum_should_match": "50%"
>             }
>         }
>     }
> }
> 当然这种需求也可以用 must、must_not、should 匹配同一个字段的方式进行组合查询.
> ```

##### 6.7 多字段的匹配 - multi_match

> `multi_match` 用来对多个字段同时进行匹配: 任意一个字段中存在相应的分词, 就可作为结果返回.
>
> ```
> 示例 1、 : 查询 name 或 desc 字段中包含 "面试经典" 的文档 —— 会对查询串进行分词:
> GET shop/_search
> {
>     "query": {
>         "multi_match": {
>             "query": "面试经典", 
>             "fields": [
>                 "name", 
>                 "desc"
>             ]
>         }
>     }
> }
> 示例 2、 : 查询 name 或 desc 字段中同时包含 "面试经典" 的文档 —— 不对查询串进行分词
> GET shop/_search
> {
>     "query": {
>         "multi_match": {
>             "query": "面试经典",
>             "type": "cross_fields", // 还有best_fields、most_fields、phrase、phrase_prefix选项
>             "operator": "and", 		// 全部匹配, or是部分匹配
>             "fields": [
>                 "name", 
>                 "desc"
>             ]
>         }
>     }
> }
> ```

##### 6.8 bool query - 布尔查询（真假查询）

> bool query, 顾名思义, 就是 **真假/有无** 查询. 包括4个子查询:
>
> **1、** must - 必须匹配, 类似于SQL中的 `=` ;
> **2、** must_not - 必须不匹配, 类似于SQL中的 `!=` ;
> **3、** should - 不强制匹配, 类似于SQL中的 `or` ;
> **4、** filter - 过滤, 将满足一定条件的文档筛选出来.
>
> **除filter之外, 每个子查询都会根据自己的条件计算出每个文档的相关度分数, 然后bool综合所有分数, 合并为一个.**
>
> ```
> GET shop/_search
> {
>     "query": {
>         "bool": {
>             "must":[ 
>                 { "match": { "name": "Java" } }
>             ], 
>             "must_not": [
>                 { "match": { "desc": "编程" } }
>             ], 
>             "should": [
>                 { "match": { "publisher": "机械工业" } }
>             ], 
>             "filter": {
>                 "bool": { 
>                     "must": [
>                         { "range": { "date": { "gte": "2010-01-01" }}},
>                         { "range": { "price": { "lte": 99.00 }}}
>                     ]
>                 }
>             }
>             
>         }
>     }
> }
> ```
>
> * 嵌套使用bool query 
>
> ```
> GET shop/_search
> {
>     "query": {
>         "bool": {
>             "should": [
>                 { "term": { "name.keyword": "Java编程思想" } },
>                 {
>                     "bool": {
>                         "must": [
>                             { "term": { "product_desc": "刷头" } }
>                         ]
>                     }
>                 }
>             ]
>         }
>     }
> }
> ```
>
> * 直接filter操作 - 使用constant_score
>
> ```
> 如果不指定query条件而直接filter, 将抛出no [query] registered for [filter], 此时通过constant_score即可实现直接filter
> GET shop/_search 
> {
>     "query": {
>     	"constant_score": {
>             "filter": {
>                 "range": { "price": { "gte": 80 } }
>             }
>         }
>     }
> }
> ```
>
> * 指定should的匹配个数 - minimum_should_match
>
> ```
> 如果组合查询中没有must, 就会至少匹配一个should
> 可以通过 minimum_should_match 指定匹配的should的个数
> GET shop/_search
> {
>     "query": {
>         "bool": {
>             "should": [
>                 { "match": { "name": "java" } }, 
>                 { "match": { "desc": "编程"} }, 
>                 { "match": { "price": 109 } }
>             ], 
>             "minimum_should_match": 2
>         }
>     }
> }
> ```

##### 6.9 ES的高级检索语法

> 1. term query - 索引词检索
>
> * term query - 不分词检索
>
> ```
> term query: 把检索串当作一个整体来执行检索, 即不会对检索串分词
> term是完全匹配检索, 要用在不分词的字段上, 如果某个field在映射中被分词了, term检索将不起作用.
> 所以, 不分词的field, 要在mapping中设置为不分词
> ES 5.x之后, 为每个text类型的字段新增了名为keyword的子字段, 是不分词的, 默认保留256个字符
> 可以使用keyword字段进行term检索. 示例:
> GET shop/_search
> {
>     "query": {
>         "term": {
>             "name.keyword": "Java编程思想"
>         }
>     }
> }
> ```
>
> * terms query - in 检索
>
> ```
> terms, 相当于多个term检索, 类似于SQL中in关键字的用法, 即在某些给定的数据中检索
> GET shop/_search
> {
>     "query": {
>         "terms": {
>             "name.keyword": [
>                 "Java编程思想", "Java并发编程的艺术"
>             ]
>         }
>     }
> }
> ```
>
> 2. prefix query - 前缀检索
>
> `prefix query`, 就是前缀检索. 比如商品name中有多个以"Java"开头的document, 检索前缀"Java"时就能检索到所有以"Java"开头的文档
>
> ```
> 扫描所有倒排索引, 性能较差.
> GET shop/_search
> {
>     "query": {
>         "prefix": { "name": "java" }
>     }
> }
> ```
>
> 3. wildcard query - 通配符检索
>
> ```
> 扫描所有倒排索引, 性能较差
> GET shop/_search
> {
>     "query": {
>         "wildcard": { "name": "ja*" }
>     }
> }
> ```
>
> 4. regexp query - 正则检索
>
> ```
> 扫描所有倒排索引, 性能较差
> GET shop/_search
> {
>     "query": {
>         "regexp": { "name": "jav[a-z]*" }
>     }
> }
> ```
>
> 5. fuzzy query - 纠错检索
>
> `fuzziness`的默认值是2 —— 表示最多可以纠错两次.
>
> 说明:`fuzziness`的值太大, 将削弱检索条件的作用, 也就是说纠错次数太多, 就会导致限定检索结果的检索条件被改变, 失去了限定作用.
>
> ```
> 示例:检索name中包含"Java"的文档, Java中缺失了一个字母a
> GET shop/_search
> {
>     "query": {
>         "match": { 
>             "name": {
>                 "query": "Jav", 
>                 "fuzziness": 1, 
>                 "operator": "and"
>             }
>         }
>     }
> }
> ```
>
> 6. boost评分权重 - 控制文档的优先级别
>
> ```
> 通过boost参数, 令满足某个条件的文档的得分更高, 从而使得其排名更靠前.
> GET shop/_search
> {
>     "query": {
>         "bool": {
>             "must": [
>                 { "match": { "name": "编程思想"} }
>             ], 
>             "should": [
>                 { 
>                    "match": { 
>                         "name": {
>                             "query": "艺术", 
>                             "boost": 2        // 提升评分权重
>                         } 
>                     }
>                 }
>             ]
>         }
>     }
> }
> ```
>
> 7. dis_max的用法 - best fields 策略
>
> 一般检索中, 检索条件会被分词, bool检索构建多个子检索 (`must` | `must_not` | `should` | `filter`), 这些子检索可能会包含多个field. 这时:
>
> **多个子检索的field各自匹配少量关键字的文档的分数 > 某个子检索的field匹配大量关键字的文档的分数**.
>
> * dis_max的提出
>
> 如果我们希望检索结果中 (检索串被分词后的) 关键字匹配越多, 这样的文档就越靠前, 而不是多个子检索中匹配少量分词的文档靠前
>
> tie_breaker的值介于0~1之间, Elasticsearch将 `bool检索的分数 * tie_breaker`的结果与dis_max的最高分进行比较, 除了取dis_max的最高分以外, 还会考虑其他的检索结果的分数.
>
> ```
> 为了增加精准度, 常用的是配合boost、minimum_should_match等参数控制检索结果.
> GET shop/_search
> {
>     "query": {
>         "dis_max": {
>             "queries": [
>                 { "match": { "name": "虚拟机" } },
>                 { "match": { "desc": "经典" } }
>             ],
>             "tie_breaker": 0.2		// 对同时满足的文档的分值进行提升
>         }
>     }
> }
> 
> GET shop/_search
> {
>     "query": {
>         "dis_max": {
>             "queries": [
>                 { 
>                     "match": { 
>                         "name": {
>                             "query": "虚拟机",
>                             "minimum_should_match": "50%",
>                             "boost": 2
>                         }
>                     }
>                 },
>                 {
>                     "match": {
>                         "desc": {
>                             "query": "经典",
>                             "minimum_should_match": "50%", 
>                             "boost": 3
>                         }
>                     }
>                 }
>             ],
>             "tie_breaker": 0.3
>         }
>     }
> }
> ```
>
> 8. exist query - 存在检索 已过期
> 9. 复杂检索的使用范例
>
> * 多条件过滤 - 包含
>
> ```\
> 检索出版时间在2012-07之后, 且至少满足下述条件中一个的文档:
> a. 名称(name)中包含"并发";
> b. 描述(desc)中包含"java";
> c. 出版社(publisher)名称中不包含"电子".
> GET shop/_search
> {
>     "query": {
>         "bool": {
>             "filter": {					// 按时间过滤
>                 "range": {
>                     "date": {"gte": "2012-07"}
>                 }
>             },
>             "should": [					// 可匹配, 可不匹配
>                 {
>                     "match": { "name": "并发" }
>                 },
>                 {
>                     "bool": {
>                         "must": {		// 必须匹配
>                             "match": { "desc": "java" }
>                         },
>                         "must_not": {	// 不能匹配
>                             "match": { "publisher": "电子" }
>                         }
>                     }
>                 }
>             ],
>             "minimum_should_match": 1	// 至少满足should中的一个条件
>         }
>     }, 
>     // 自定义排序
> 	"sort": [
>         { "price": { "order": "desc" } }
>     ]
> }
> 注意:排序的字段最好是数字, 或日期, 因为字符串字段会被分词, ES会通过分词后的某个词去排序, 结果难以预测.
> ```
>
> * 多条件拼接 - 包含 + 范围 + 排序
>
> ```
> 匹配检索: name中包含"java"却不包含"虚拟机";
> 范围检索: 价格大于50、小于80;
> 结果排序: 按照价格升序排序
> GET shop/_search
> {
>     "query": {
>         "bool": {
>             "must": {						// 必须匹配
>                 "match": { "name": "java" }
>             }, 
>             "must_not": {					// 必须不匹配
>                 "match": { "name": "虚拟机" }
>             },
>             "filter": {
>                 "range": {
>                     "price": {
>                         "gte": 40,
>                         "lte": 80,
>                         "boost": 2.0	// 设置得分的权重值(提升值), 默认是1.0
>                     }
>                 }
>             }
>         }
>     }
> }
> 
> ```
>
> * 定制检索结果的排序规则
>
> **(1) 默认排序规则:**
>
> ES默认是按检索结果的分值(_score)降序排列的.
>
> 某些情况下, 可能存在无实际意义的_score, 比如filter时所有_score的值都相同:
>
> ```
> GET website/_search
> {
>     "query": {
>         "bool": {
>             "filter": {
>                 "term": {
>                     "author_id": 5520	// 此时所有符合条件的_score都为0
>                 }
>             }
>         }
>     }
> }
> 
> // 或通过constant_score过滤: 
> GET website/_search
> {
>     "query": {
>         "constant_score": {
>             "filter": {
>                 "term": {
>                     "author_id": 5520	// 此时所有符合条件的_score都为1
>                 }
>             }
>         }
>     }
> }
> ```
>
> **(2) 定制排序规则:**
>
> ```
> GET website/_search
> {
>     "query": {
>         "constant_score": {
>             "filter": {
>                 "term": {
>                     "author_id": 5520
>                 }
>             }
>         }
>     }, 
>     "sort": [
>         {
>             "post_date": { "order": "asc" }
>         }
>     ]
> }
> ```
>
> 

