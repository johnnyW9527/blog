#### 4 配置ES的映射

##### 4.1 什么是映射

> (1)映射(mapping): 定义index的元数据, 指定要索引并存储的文档的字段类型.
>
> 也就是说映射决定了Elasticsearch在建立倒排索引、进行检索时对文档采取的相关策略, 如数字类型、日期类型、文本类型等等.
>
> 需要注意的是: **检索时用到的分析策略, 要和建立索引时的分析策略相同, 否则将导致数据不准确**
>
> (2)ES对不同的类型有不同的存储和检索策略.
>
> **1、** 比如: 对full text型的数据类型(如text), 在索引时, 会经过各类处理 (包括分词、normalization(时态转换、同义词转换、大小写转换)等处理), 才会建立到索引数据中.
> **2、** 再比如: 对exact value(如date), 在索引的分词阶段, 会将整个value作为一个关键词建立到倒排索引中.

##### 4.2 映射组成

> 每个index都有一 (至多) 个type, 每个type对应一个mapping.
>
> 在Elasticsearch 6.X版本开始, 1个index只能有1个type.
>
> 每个mapping都由下述部分组成:
>
> **1、** 元字段: `_index`、`_type`、`_id` 和 `_source`.
>
> **2、** field/properties(字段或属性): **同一index中, 同名的field的映射配置必须相同**
>
> a) 因为index是根据`_type`元字段来区分type的, 也就是存储的每个文档中都有`_type`等元字段, 如果相同名称的field的映射(`_type`字段的值)不同, Elasticsearch在解析时就会出现冲突.
> b) 这些参数可以例外: `copy_to、dynamic、enabled、ignore_above、include_in_all`.

##### 4.3 元字段

每个文档都有与之关联的元数据 —— ES内部为所有的文档配备的field, 都是以下划线`_`开头的内置字段.

> 1. _index 文档所属的索引
>
> `_index`标注document属于哪个index, 是一个虚拟字段, 不会被添加到Lucene索引中.
>
> **将类似的文档 (也就是具有相同field的文档) 存放到同一个index中, 是一种良好的数据建模思想.**
>
> 提供大量查询的index, 最好不要同时提供大量的统计、聚合等操作——通过把特定的index路由到指定的shard上, 便于系统的优化.
>
> 索引名称必须是小写的字母, 不能以下划线"_"开头, 不能包含逗号 ","
>
> 在term或者terms查询, 聚合、脚本以及排序时, 可以访问`_index`字段的值.
>
> 在多个索引中执行查询时, 可以通过添加查询子句来关联特定的索引文档, 使用示例——同时查询多种index:
>
> ```
> GET website,book_shop/_search
> {
>     "query": {
>         "terms": {    // 查询_index是website和book_shop的文档
>             "_index": [ "website", "book_shop"] }
>     },
>     "aggs": {
>         "indices": {  // 对_index字段进行聚合操作
>             "terms": { "field": "_index", "size": 10 }
>         }
>     },
>     "sort": {         // 对_index字段进行排序操作
>         "_index": { "order": "asc" }
>     },
>     "script_fields": {  // 使用脚本, 显示_index字段
>         "index_name": {
>             "script": { 
>                 "lang": "painless",
>                 "source": "doc['_index']"
>             }
>         }
>     }
> }
> ```
>
> 2. _uid-包含_type和_id的复合字段
>
> _uid是_type和_id的组合, 形式为{type}#{id}. 可以用于查询、聚合、脚本和排序.
>
> (1)添加文档:
>
> ```
> PUT website/blog/4
> {
>     "text": "blog with ID 4"
> }
> 
> PUT website/blog/5?refresh=true
> {
>     "text": "blog with ID 5"
> }
> ```
>
> (2)检索文档:
>
> ```
> GET website/_search
> {
>     "query": { 
>         "terms": {       // 通过_uid查询_type和_id的复合字段
>             "_uid": ["blog#4", "blog#5"]
>         }
>     },
>     "aggs": {
>         "uid_aggs": {
>             "terms": {    // 这里通过_uid聚合的操作已经过期
>                 "field": "_id", "size": 10
>               }
>         }
>     }, 
>     "sort": {             // 这里通过_uid排序的操作已经过期
>         "_id": { "order": "desc"}
>     }, 
>     "script_fields": {
>         "uid_script": {
>             "script": {   // 这里对_uid的脚本操作已经过期
>                 "lang": "painless", 
>                 "source": "doc['_id']" 
>             }
>         }
>     }
> }
> 
> ```
>
> 3. _type 文档的类型
>
> `_type`元字段用来标注document属于哪个类型, 也被称作映射类型.
>
> 注意: type的名称可以是大写或小写字母, 但不能以下划线"_"开头, 不能包含逗号",".
>
> 在Elasticsearch 6.0之前的版本中, 一个index可能会被划分为多个type, 例如: 商品中有电子商品, 服装商品, 生鲜商品...
>
> 但**在Elasticsearch 6.0之后, 一个index只能包含一个type, 否则将出现错误.**
>
> 每一个索引文档都包含`_type`和`_id`字段, `_type`字段的目的是通过类型名加快搜索速度.·`_type`字段可以在查询、聚合、排序以及脚本中访问到.
>
> 4. _id 文档的id
>
> `_id`代表document的唯一标识, 与`_index`和`_type`一起, 唯一标识和定位一个document.
>
> **注意: 可以手动指定document的id(PUT index/type/id), 也可以不指定, Elasticsearch在添加文档时会自动为其创建id.**
>
> ```
> GET website/_search
> {
>     "query": {
>         "terms": {"_id" : ["1", "2"]}
>     },
>     "aggs": {
>         "id_aggs": {
>             "terms": {
>                 "field": "_id", "size": 10
>             }
>         }
>     }, 
>     "script_fields": {
>         "id_script": {
>             "script": {
>                 "lang": "painless", 
>                 "source": "doc['_id']"
>             }
>         }
>     }
> }
> ```
>
> 5. _source 文档原始JSON内容
>
> 文档的原始JSON内容将索引到`_source`字段中, 该字段本身不建立索引, 但是会被存储.搜索文档时默认返回该字段及其内容, 但无法用于搜索.
>
> * 关闭_source功能
>
> `_source`功能默认是开启的, 它会产生额外的存储开销, 可以关闭
>
> ```
> PUT website
> {
>     "mappings": {
>         "blog": {
>             "_source": {"enabled": false}
>         }
>     }
> }
> 
> // 或者:
> PUT website/_mapping/blog
> {
>     "_source": {"enabled": false}	
> }
> 
> ```
>
> 注意:必须在创建索引时关闭, 创建之后不允许修改, 否则将会发生如下错误:
>
> ```
> {
>   "error": {
>     "root_cause": [
>       {
>         "type": "resource_already_exists_exception",
>         "reason": "index [website/zIUdhInBQsOUi_4Tt2SSkQ] already exists",
>         "index_uuid": "zIUdhInBQsOUi_4Tt2SSkQ",
>         "index": "website"
>       }
>     ],
>     "type": "resource_already_exists_exception",
>     "reason": "index [website/zIUdhInBQsOUi_4Tt2SSkQ] already exists",
>     "index_uuid": "zIUdhInBQsOUi_4Tt2SSkQ",
>     "index": "website"
>   },
>   "status": 400
> }
> ```
>
> * 查询时指定返回字段
>
> **_source功能被禁止, 将造成大量功能无法使用**
>
> partial update 功能基于_source实现;
> hilight 高亮显示功能基于_source实现;
> reindex 重建索引功能基于_source实现, 不需要从其他外部存储中获取数据, 再index;
> 基于_source定制返回field;
> 调试query时更容易, 因为可以很直观地看到_source内容……
>
> 可以在创建index时, 在mapping中通过`includes/excludes`参数来减少`_source`字段的内容:
>
> ```
> PUT logs
> {
>     "mappings": {
>         "event": {
>             "_source": {
>                 "includes": ["*.count", "meta.*"],         // 包含的字段
>                 "excludes": ["meta.desc", "meta.other.*"]  // 不包含的字段
>             }
>         }
>     }
> }
> 
> ```
>
> **移除的字段不会被存储在_source中, 但仍然可以搜索到这些字段.**
>
> 可以在检索时, 禁止返回原始内容:
>
> ```
> GET website/blog/1?_source=false
> ```
>
> 如果只想获取`_source`的部分内容, 可以使用`_source_includes`或`_source_excludes`参数:
>
> ```
> GET website/blog/1?_source_includes=title,content
> GET website/blog/1?_source_excludes=post_date,author_id
> ```
>
> 6. _size _source字段占用的字节数
>
> 记录`_source`字段占用的字节数, 由插件mapper-size提供.
>
> 7. _field_names 文档所有非空字段名
>
> 该字段可以用在查询、聚合以及脚本中 —— 用于查找指定字段的值非空的文档是否存在.
>
> ```
> GET website/_search
> {
>     "query": {
>         "terms": {"_field_names": ["content"]}
>     }
> }
> ```
>
> 8. 路由元字段 _routing 自定义的路由值
>
> 用于将文档路由到指定的分片上. 通过如下公式将文档路由到特定的分片:
>
> shard_num = hash(_routing) % num_primary_shards
>
> 如果不指定`_routing`的值, 默认使用文档的`_id`字段. 如果存在父文档则使用其`_parent`的编号.
>
> 可以通过为某些文档都指定相同的路由值, 来实现对这些文档的自定义路由功能:
>
> ```
> // 此文档使用'user_5220'作为其路由值, 在查询、更新、删除时同样需要提供此路由值
> PUT website/blog/1?routing=user_5220
> {
>     "title": "xxx"
> }
> ```
>
> `_routing`字段可以在查询、聚合、脚本以及排序的时候访问. 比如直接指定路由值来搜索相关的文档:
>
> ```
> GET website/_search
> {
>     "query": {
>         "terms": {"_routing": [ "user_5220" ] }
>     }
> }
> ```

##### 4.4 字段的类型

Elasticsearch中每个field都对应一至多个数据类型.

> 1. 字符串类型-string(不再使用)
>
> ```
> PUT website
> {
>     "mappings": {
>         "blog": {
>             "properties": {
>                 "title": {"type": "string"}, 	// 全文本
>                 "tags": {"type": "string", "index": "not_analyzed"}	// 关键字, 不分词
>             }
>         }
>     }
> ```
>
> 2. 文本类型-text
>
>  **当一个字段需要用于全文搜索(会被分词), 比如产品名称、产品描述信息, 就应该使用text类型.**
>
> text的内容会被分词, 可以设置是否需要存储: `"index": "true|false"`.
> text类型的字段不能用于排序, 也很少用于聚合.
>
> ```
> PUT website
> {
> 	"mappings": {
>         "blog": {
>             "properties": {
>         		"summary": {"type": "text", "index": "true"}
>             }
>         }
>     }
> }
> ```
>
> 3 关键字类型-keyword
>
>  **当一个字段需要按照精确值进行过滤、排序、聚合等操作时, 就应该使用keyword类型.**
>
> keyword的内容不会被分词, 可以设置是否需要存储: `"index": "true|false"`.
>
> ```
> PUT website
> {
> 	"mappings": {
>         "blog": {
>             "properties": {
>         		"tags": {"type": "keyword", "index": "true"}
>             }
>         }
>     }
> }
> ```
>
> 4. 数字类型
>
> | 类型         | 说明                                                         |
> | ------------ | ------------------------------------------------------------ |
> | byte         | 有符号的8位整数, 范围: [-128 ~ 127]                          |
> | short        | 有符号的16位整数, 范围: [-32768 ~ 32767]                     |
> | integer      | 有符号的32位整数, 范围: [\(-2^{31}\) ~ \(2^{31}\)-1]         |
> | long         | 有符号的64位整数, 范围: [\(-2^{63}\) ~ \(2^{63}\)-1]         |
> | float        | 32位单精度浮点数                                             |
> | double       | 64位双精度浮点数                                             |
> | half_float   | 16位半精度IEEE 754浮点类型                                   |
> | scaled_float | 缩放类型的的浮点数, 比如price字段只需精确到分, 57.34缩放因子为100, 存储结果为5734 |
>
> 尽可能选择范围小的数据类型, 字段的长度越短, 索引和搜索的效率越高;优先考虑使用带缩放因子的浮点类型.
>
> ```
> PUT shop
> {
>     "mappings": {
>         "book": {
>             "properties": {
>                 "name": {"type": "text"},
>                 "quantity": {"type": "integer"},  // integer类型
>                 "price": {
>                     "type": "scaled_float",       // scaled_float类型
>                     "scaling_factor": 100
>                 }
>             }
>         }
>     }
> }
> ```
>
> 5. 日期类型-date
>
> JSON没有日期数据类型, 所以在ES中, 日期可以是:
>
> * 包含格式化日期的字符串, "2018-10-01", 或"2018/10/01 12:10:30".
> * 代表时间毫秒数的长整型数字.
> * 代表时间秒数的整数.
>
> 如果时区未指定, 日期将被转换为UTC格式, 但存储的却是长整型的毫秒值.
> 可以自定义日期格式, 若未指定, 则使用默认格式: `strict_date_optional_time||epoch_millis`
>
> (1)使用日期格式示例:
>
> ```
> // 添加映射
> PUT website
> {
>     "mappings": {
>         "blog": {
>             "properties": {
>                 "pub_date": {"type": "date"}   // 日期类型
>             }
>         }
>     }
> }
> 
> // 添加数据
> PUT website/blog/11
> { "pub_date": "2018-10-10" }
> 
> PUT website/blog/12
> { "pub_date": "2018-10-10T12:00:00Z" }	// Solr中默认使用的日期格式
> 
> PUT website/blog/13
> { "pub_date": "1589584930103" }			// 时间的毫秒值
> ```
>
> (2)多种日期格式:
>
> 多个格式使用双竖线`||`分隔, 每个格式都会被依次尝试, 直到找到匹配的.第一个格式用于将时间毫秒值转换为对应格式的字符串.
>
> ```
> // 添加映射
> PUT website
> {
>     "mappings": {
>         "blog": {
>             "properties": {
>                 "date": {
>                     "type": "date",  // 可以接受如下类型的格式
>                     "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"
>                 }
>             }
>         }
>     }
> }
> ```
>
> 6. 布尔类型 - boolean
>
> 可以接受表示真、假的字符串或数字:
>
> * 真值: true, "true", "on", "yes", "1"...
> * 假值: false, "false", "off", "no", "0", ""(空字符串), 0.0, 0
>
> 7. 二进制型 - binary
>
> 二进制类型是Base64编码字符串的二进制值, 不以默认的方式存储, 且不能被搜索. 有2个设置项:
>
> (1) `doc_values`: 该字段是否需要存储到磁盘上, 方便以后用来排序、聚合或脚本查询. 接受`true`和`false`(默认);
> (2) `store`: 该字段的值是否要和`_source`分开存储、检索, 意思是除了`_source`中, 是否要单独再存储一份. 接受`true`或`false`(默认).
>
> ```
> // 添加映射
> PUT website
> {
>     "mappings": {
>         "blog": {
>             "properties": {
>                 "blob": {"type": "binary"}   // 二进制
>             }
>         }
>     }
> }
> // 添加数据
> PUT website/blog/1
> {
>     "title": "Some binary blog",
>     "blob": "hED903KSrA084fRiD5JLgY=="
> }
> 注意: Base64编码的二进制值不能嵌入换行符\n, 逗号(0x2c)等符号.
> ```
>
> 8. 范围类型 - range
>
> | 类型          | 范围                                           |
> | ------------- | ---------------------------------------------- |
> | integer_range | \(-2^{31}\) ~ \(2^{31}-1\)                     |
> | long_range    | \(-2^{63}\) ~ \(2^{63}-1\)                     |
> | float_range   | 32位单精度浮点型                               |
> | double_range  | 64位双精度浮点型                               |
> | date_range    | 64位整数, 毫秒计时                             |
> | ip_range      | IP值的范围, 支持IPV4和IPV6, 或者这两种同时存在 |
>
> ```
> PUT company
> {
>     "mappings": {
>         "department": {
>             "properties": {
>                 "expected_number": {  // 预期员工数
>                     "type": "integer_range"
>                 },
>                 "time_frame": {       // 发展时间线
>                     "type": "date_range", 
>                     "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"
>                 },
>                 "ip_whitelist": {     // ip白名单
>                     "type": "ip_range"
>                 }
>             }
>         }
>     }
> }
> 
> ```
>
> ```
> PUT company/department/1
> {
>     "expected_number" : {
>         "gte" : 10,
>         "lte" : 20
>     },
>     "time_frame" : { 
>         "gte" : "2018-10-01 12:00:00", 
>         "lte" : "2018-11-01"
>     }, 
>     "ip_whitelist": "192.168.0.0/16"
> }
> 
> ```
>
> ```
> GET company/department/_search
> {
>     "query": {
>         "term": {
>             "expected_number": {
>                 "value": 12
>             }
>         }
>     }
> }
> GET company/department/_search
> {
>     "query": {
>         "range": {
>             "time_frame": {
>                 "gte": "208-08-01",
>                 "lte": "2018-12-01",
>                 "relation": "within" 
>             }
>         }
>     }
> }
> ```
>
> 9. 复杂数据类型-数组array
>
> ES中没有专门的数组类型, 直接使用[]定义即可;
>
> **数组中所有的值必须是同一种数据类型, 不支持混合数据类型的数组**:
>
> **1、** 字符串数组: ["one", "two"];
> **2、** 整数数组: [1, 2];
> **3、** 由数组组成的数组: [1, [2, 3]], 等价于[1, 2, 3];
> **4、** 对象数组: [{"name": "Tom", "age": 20}, {"name": "Jerry", "age": 18}].
>
> 注意:
>
> - 动态添加数据时, 数组中第一个值的类型决定整个数组的类型;
> - 不支持混合数组类型, 比如[1, "abc"];
> - 数组可以包含null值, 空数组[]会被当做missing field —— 没有值的字段.
>
> 10. 对象类型 - object
>
> JSON文档是分层的: 文档可以包含内部对象, 内部对象也可以包含内部对象.
>
> (1)添加示例:
>
> ```
> PUT employee/developer/1
> {
>     "name": "ma_shoufeng",
>     "address": {
>         "region": "China",
>         "location": {"province": "GuangDong", "city": "GuangZhou"}
>     }
> }
> ```
>
> (2)存储方式:
>
> ```
> {
>     "name":                       "ma_shoufeng",
>     "address.region":             "China",
>     "address.location.province":  "GuangDong", 
>     "address.location.city":      "GuangZhou"
> }
> ```
>
> (3)文档的映射结构类似为
>
> ```
> PUT employee
> {
>     "mappings": {
>         "developer": {
>             "properties": {
>                 "name": { "type": "text", "index": "true" }, 
>                 "address": {
>                     "properties": {
>                         "region": { "type": "keyword", "index": "true" },
>                         "location": {
>                             "properties": {
>                                 "province": { "type": "keyword", "index": "true" },
>                                 "city": { "type": "keyword", "index": "true" }
>                             }
>                         }
>                     }
>                 }
>             }
>         }
>     }
> }
> ```
>
> 11. 嵌套类型 - nested
>
> 嵌套类型是对象数据类型的一个特例, 可以让array类型的对象被独立索引和搜索.
>
> * 对象数组时如何存储的
>
> ```
> PUT game_of_thrones/role/1
> {
>     "group": "stark",
> 	"performer": [
>         {"first": "John", "last": "Snow"},
>         {"first": "Sansa", "last": "Stark"}
>     ]
> }
> {
>     "group": 	         "stark",
>     "performer.first": [ "john", "sansa" ],
>     "performer.last":  [ "snow", "stark" ]
> }
> 可以看出, user.first和user.last会被平铺为多值字段, 这样一来, John和Snow之间的关联性就丢失了.
> 
> 在查询时, 可能出现John Stark的结果.
> ```
>
> * 用nested类型解决object类型的不足
>
> 如果需要对以最对象进行索引, 且保留数组中每个对象的独立性, 就应该使用嵌套数据类型.嵌套对象实质是将每个对象分离出来, 作为隐藏文档进行索引.
>
> ```
> PUT game_of_thrones
> {
>     "mappings": {
>         "role": {
>             "properties": {
>                 "performer": {"type": "nested" }
>             }
>         }
>     }
> }
> PUT game_of_thrones/role/1
> {
>     "group" : "stark",
>     "performer" : [
>         {"first": "John", "last": "Snow"},
>         {"first": "Sansa", "last": "Stark"}
>     ]
> }
> GET game_of_thrones/_search
> {
>     "query": {
>         "nested": {
>             "path": "performer",
>             "query": {
>                 "bool": {
>                     "must": [
>                         { "match": { "performer.first": "John" }},
>                         { "match": { "performer.last":  "Snow" }} 
>                     ]
>                 }
>             }, 
>             "inner_hits": {
>                 "highlight": {
>                     "fields": {"performer.first": {}}
>                 }
>             }
>         }
>     }
> }
> ```
>
> 12. 地理数据类型
>
> 地理点类型用于存储地理位置的经纬度对, 可用于:
>
> - 查找一定范围内的地理点;
> - 通过地理位置或相对某个中心点的距离聚合文档;
> - 将距离整合到文档的相关性评分中;
> - 通过距离对文档进行排序.
>
> ```
> PUT employee
> {
>     "mappings": {
>         "developer": {
>             "properties": {
>                 "location": {"type": "geo_point"}
>             }
>         }
>     }
> }
> // 方式一: 纬度 + 经度键值对
> PUT employee/developer/1
> {
>     "text": "小蛮腰-键值对地理点参数", 
>     "location": {
>         "lat": 23.11, "lon": 113.33		// 纬度: latitude, 经度: longitude
>     }
> }
> 
> // 方式二: "纬度, 经度"的字符串参数
> PUT employee/developer/2
> {
>   "text": "小蛮腰-字符串地理点参数",
>   "location": "23.11, 113.33" 			// 纬度, 经度
> }
> 
> // 方式三: ["经度, 纬度"] 数组地理点参数
> PUT employee/developer/3
> {
>   "text": "小蛮腰-数组参数",
>   "location": [ 113.33, 23.11 ] 		// 经度, 纬度
> }
> GET employee/_search
> {
>     "query": { 
>         "geo_bounding_box": { 
>             "location": {
>                 "top_left": { "lat": 24, "lon": 113 },		// 地理盒子模型的上-左边
>                 "bottom_right": { "lat": 22, "lon": 114 }	// 地理盒子模型的下-右边
>             }
>         }
>     }
> }
> ```
>
> 13. 专门数据类型
>
> 1. IP类型
>
> IP类型的字段用于存储IPv4或IPv6的地址, 本质上是一个长整型字段.
>
> ```
> PUT employee
> {
>     "mappings": {
>         "customer": {
>             "properties": {
>                 "ip_addr": { "type": "ip" }
>             }
>         }
>     }
> }
> PUT employee/customer/1
> { "ip_addr": "192.168.1.1" }
> GET employee/customer/_search
> {
>     "query": {
>         "term": { "ip_addr": "192.168.0.0/16" }
>     }
> }
> 
> ```
>
> 2. 计数数据类型 - token_count
>
> token_count类型用于统计字符串中的单词数量.
>
> 本质上是一个整数型字段, 接受并分析字符串值, 然后索引字符串中单词的个数.
>
> ```
> PUT employee
> {
>     "mappings": {
>         "customer": {
>             "properties": {
>                 "name": { 
>                     "type": "text",
>                     "fields": {
>                         "length": {
>                             "type": "token_count", 
>                             "analyzer": "standard"
>                         }
>                     }
>                 }
>             }
>         }
>     }
> }
> PUT employee/customer/1
> { "name": "John Snow" }
> PUT employee/customer/2
> { "name": "Tyrion Lannister" }
> 
> GET employee/customer/_search
> {
>     "query": {
>         "term": { "name.length": 2 }
>     }
> }
> 
> ```
>
> 

##### 4.5 如何配置mapping

> (1)必读说明:
>
> **1、** 创建mapping时, 可以指定每个field是否需要:
>
> 索引: `"index": true` —— 默认配置
> 不索引: `"index": false`
>
> **2、** `mapping root object`:
>
> 每个type对应的mapping的JSON串, 包括`properties, metadata(_id, _source, _type) , settings(analyzer) , 其他settings(如include_in_all)`
>
> **需求: 创建名为website的索引, 包含一个user类型. user类型中禁用元字段`_all`**
>
> ```
> PUT website
> {
>     "mappings": {
>         "user": {       // 这就是一个root object
>             "_all": { "enabled": false },  // 禁用_all字段
>             "properties": {
>                 "user_id": { "type": "text" },
>             	  "name": {
>                     "type": "text",
>                     "analyzer": "english"
>                 },
>                 "age": { "type": "integer" },
>                 "sex": { "type": "keyword" },
>                 "birthday": {
>                     "type": "date", 
>                     "format": "strict_date_optional_time||epoch_millis"
>                 },
>                 "address": {
>                     "type": "text",
>                     "index": false         // 不分词
>                 }
>             }
>         }
>     }
> }
> ```
>
> 过期提示说明 —— 这里使用的是Elasticsearch 6.6.0版本:
>
> **1、** 是否索引的API已经做了修改, 若使用"analyzed" | "not_analyzed" | "yes" | "no"等, 将抛出如下警告:
>
> **2、** `_all`元字段也将在7.0版本中移除, 它建议我们使用`copy_to`定制自己的`all field`:

##### 4.6 更新mapping

> (1)必读说明:
>
> * 映射一旦创建完成, 就不允许修改:Elasticsearch对文档的分析、存储、检索等过程, 都是严格按照mapping中的配置进行的. 如果允许后期修改mapping, 在检索时对索引的处理将存在不一致的情况, 导致数据检索行为不准确.
> * **只能在创建index的时候手动配置mapping, 或者新增field mapping, 但是不能update field mapping.**
>
> (2)更新mapping出现异常
>
> * 修改已经创建好的mapping
>
> ```
> PUT website
> {
>     "mappings": {
>         "user": {
>             "properties": {
>                 "author_id": { "type": "text" }
>             }
>         }
>     }
> }
> ```
>
> * 抛出如下错误 —— 索引已经存在的异常:
>
> ```
> {
>   "error": {
>     "root_cause": [
>       {
>         "type": "resource_already_exists_exception",
>         "reason": "index [website/mVYk4-a7RMOZbkcCp2avfw] already exists",
>         "index_uuid": "mVYk4-a7RMOZbkcCp2avfw",
>         "index": "website"
>       }
>     ],
>     "type": "resource_already_exists_exception",
>     "reason": "index [website/mVYk4-a7RMOZbkcCp2avfw] already exists",
>     "index_uuid": "mVYk4-a7RMOZbkcCp2avfw",
>     "index": "website"
>   },
>   "status": 400
> }
> ```
>
> (3)向已有mapping中添加字段及其映射信息:
>
> ```
> PUT website/_mapping/user		// 修改user类型的_mapping, 注意API的顺序
> {
>     "properties": {
>         "new_field": {
>             "type": "text",
>             "index": false
>         }
>     }
> }
> ```



